
use crate::script::{ast::{Assign, Ast, BinaryOpType, BinaryOperator, Block, Call, Class, Expr, ExpressionStmt, FunctionStmt, Get, IfStmt, Literal, LiteralType, Logical, LogicalType, ReturnStmt, Set, Stmt, Super, This, UnaryOpType, UnaryOperator, VarStmt, Variable, WhileStmt}, tokens::{Token, TokenType}, vm::{chunk::{BytecodeIndex, ConstIndex, Offset, StackIndex}, gc::{Context, ObjectId}, object::ObjFunction}};

use super::{chunk::{Chunk, OpCode}, value::Value};

type Op = OpCode;

// type Func = (FuncType, ObjectId);


pub struct Compiler {
    line:        usize,
    scope_depth: usize,
    functions:   Vec<Func>
}

#[derive(Debug)]
struct Local {
    name:        Token,
    depth:       usize,
    initialized: bool,
}

enum VariableType {
    Global,
    Local,
}

enum FuncType {
    Function,
    Script,
}

struct Func {
    pub type_:    FuncType,
    pub locals:   Vec<Local>,
    pub func_obj: ObjectId,
}


#[derive(Debug)]
pub struct CompileError {
    pub msg: String
}

pub type CompilerResult<T> = Result<T, CompileError>;

#[derive(Debug)]
enum JumpType {
    IfFalse,
    IfTrue,
    Always,
}

impl Func {
    pub fn new(type_: FuncType, func_obj: ObjectId, first_slot: Local) -> Self {
        Self {
            type_,
            func_obj,
            locals: vec![first_slot],
        }
    }
}

impl Compiler {

    fn new(ctx: &mut Context) -> Self {
        let name = "script";

        let func  = ObjFunction::new(name.to_owned(), 0);
        let id    = ctx.add(func.into());

        let script_local = Local {
            name:        Token::new(TokenType::Identifier, "", 0, 0),
            depth:       0,
            initialized: true,
        };

        let func = Func::new(FuncType::Script, id, script_local);

        Self {
            line:        0,
            scope_depth: 0,
            functions:   vec![func],
        }
    }

    pub fn compile(ast: Ast, ctx: &mut Context) -> CompilerResult<ObjectId> {

        let mut compiler = Self::new(ctx);

        for stmt in ast.stmts {
            compiler.compile_stmt(stmt, ctx)?;
        }

        compiler.write_op(Op::Return, ctx);

        Ok(compiler.functions.first().expect("Function stack cannot be empty").func_obj)

    }

    // Statements

    fn compile_stmt(&mut self, stmt: Stmt, ctx: &mut Context) -> CompilerResult<()> {
        match stmt {
            Stmt::Block      (stmt) => self.compile_block_stmt (stmt,      ctx)?,
            Stmt::Class      (stmt) => self.compile_class_decl (stmt),
            Stmt::Expression (stmt) => self.compile_expr_stmt  (stmt,      ctx),
            Stmt::Function   (stmt) => self.compile_func_decl  (stmt,      ctx)?,
            Stmt::If         (stmt) => self.compile_if_stmt    (stmt,      ctx)?,
            Stmt::Print      (stmt) => self.compile_print_stmt (stmt.expr, ctx),
            Stmt::Return     (stmt) => self.compile_return_stmt(stmt),
            Stmt::Var        (stmt) => self.compile_var_decl   (stmt,      ctx)?,
            Stmt::While      (stmt) => self.compile_while_stmt (stmt,      ctx)?,
        };

        Ok(())
    }

    // statments must not leave "temporaries" on the stack (which are generated by expressions)

    fn compile_block_stmt(&mut self, block: Block, ctx: &mut Context) -> CompilerResult<()> {
        self.begin_scope();

        for stmt in *block.stmts {
            self.compile_stmt(stmt, ctx)?;
        }

        self.end_scope(ctx);
        Ok(())
    }

    fn compile_class_decl(&mut self, _class: Class) {
        todo!()
    }

    fn compile_expr_stmt(&mut self, expr_stmt: ExpressionStmt, ctx: &mut Context) {
        self.compile_expr(expr_stmt.expr, ctx);
        self.write_pop(ctx);
    }

    fn compile_func_decl(&mut self, func: FunctionStmt, ctx: &mut Context) -> CompilerResult<()> {

        let index = self.declare_variable(func.name.clone(), ctx);
        self.mark_initialized();

        for arg in func.params.iter() {
            self.declare_local(arg);
        }

        self.make_function(func.name, func.params.len(), *func.body, FuncType::Function, ctx)?;

        if self.scope_depth == 0 {
            self.define_global(index, ctx);
        }

        Ok(())
    }

    fn make_function(&mut self, name: Token, arity: usize, body: Vec<Stmt>, func_type: FuncType, ctx: &mut Context) -> CompilerResult<ObjectId> {
        let obj  = ObjFunction::new(name.lexeme.clone(), arity);
        let obj  = ctx.add(obj.into());

        self.push_func(func_type, obj, Local {
            name,
            depth:       self.scope_depth +1,
            initialized: true,
        });

        self.compile_block_stmt(Block { stmts: Box::new(body) }, ctx)?;

        let func = self.pop_func();

        self.emit_constant(Value::Obj(func.func_obj), ctx);

        Ok(obj)

    }

    fn compile_if_stmt(&mut self, if_stmt: IfStmt, ctx: &mut Context) -> CompilerResult<()> {
        self.compile_expr(if_stmt.condition, ctx);
        let jump_then_op = self.emit_jump(JumpType::IfFalse, ctx);
        self.write_pop(ctx); // Pop the condition temporary if no jump

        self.compile_stmt(*if_stmt.then_branch, ctx)?;
        let jump_else_op = self.emit_jump(JumpType::Always, ctx);

        self.patch_jump(jump_then_op, ctx);
        self.write_pop(ctx); // Pop the condition temporary if jump
        if let Some(stmt) = if_stmt.else_branch {
            self.compile_stmt(*stmt, ctx)?;
        }

        self.patch_jump(jump_else_op, ctx);

        Ok(())
    }


    fn compile_print_stmt(&mut self, expr: Expr, ctx: &mut Context) {
        self.compile_expr(expr, ctx);
        self.write_op(Op::Print, ctx);
    }

    fn compile_return_stmt(&mut self, _return: ReturnStmt) {
        todo!()
    }

    fn compile_var_decl(&mut self, stmt: VarStmt, ctx: &mut Context) -> CompilerResult<()> {
        let index = self.declare_variable(stmt.name, ctx);
        let local = self.scope_depth > 0;

        match stmt.initializer {
            Some(expr) =>   self.compile_expr(expr, ctx),
            None       => { self.write_op(Op::Nil, ctx); }
        }

        if local {
            self.mark_initialized();
            // Local delcarations are allowed to leave stack locals
        }
        else {
            self.define_global(index, ctx);
            // Global declarations must not
        }
        Ok(())
    }

    fn declare_variable(&mut self, name: Token, ctx: &mut Context) -> ConstIndex {
        self.line = name.line;

        let local = self.scope_depth > 0;

        if local {
            self.declare_local(&name);
            ConstIndex(0)
        }
        else {
            self.make_identifier_constant(name.clone(), ctx)
        }
    }

    fn compile_while_stmt(&mut self, while_: WhileStmt, ctx: &mut Context) -> CompilerResult<()> {
        let loop_start = BytecodeIndex(self.current_chunk(ctx).code.len());

        self.compile_expr(while_.condition, ctx);

        let exit_jump_op = self.emit_jump(JumpType::IfFalse, ctx);
        self.write_pop(ctx);

        self.compile_stmt(*while_.body, ctx)?;
        self.emit_loop(loop_start, ctx);

        self.patch_jump(exit_jump_op, ctx);
        self.write_pop(ctx);

        Ok(())
    }


    // Expressions

    fn compile_expr(&mut self, expr: Expr, ctx: &mut Context) {
        match expr {
            Expr::Assign   (expr) => self.compile_assign_expr (expr,       ctx),
            Expr::Binary   (expr) => self.compile_binary_expr (expr,       ctx),
            Expr::Call     (expr) => self.compile_call_expr   (expr),
            Expr::Get      (expr) => self.compile_get_expr    (expr,       ctx),
            Expr::Grouping (expr) => self.compile_expr        (*expr.expr, ctx),
            Expr::Literal  (expr) => self.compile_literal_expr(expr,       ctx),
            Expr::Logical  (expr) => self.compile_logical_expr(expr,       ctx),
            Expr::Set      (expr) => self.compile_set_expr    (expr,       ctx),
            Expr::Super    (expr) => self.compile_super_expr  (expr),
            Expr::This     (expr) => self.compile_this_expr   (expr),
            Expr::Unary    (expr) => self.compile_unary_expr  (expr,       ctx),
            Expr::Variable (expr) => self.compile_var_expr    (expr,       ctx),
        };
    }

    fn compile_literal_expr(&mut self, literal: Literal, ctx: &mut Context) {
        let value = literal.value;
        self.line = value.line;

        match literal.type_ {
            LiteralType::Number => {
                let value = Value::Number(to_number(&value.lexeme));
                self.emit_constant(value, ctx);
            },
            LiteralType::String => {
                let obj   = ctx.add_string(&value.lexeme);
                let value = Value::new_obj(obj);

                self.emit_constant(value, ctx);
            },
            LiteralType::True   => { self.write_op(Op::True,  ctx); },
            LiteralType::False  => { self.write_op(Op::False, ctx); },
            LiteralType::Nil    => { self.write_op(Op::Nil,   ctx); },
        };
    }

    fn compile_logical_expr(&mut self, logical: Logical, ctx: &mut Context) {
        self.compile_expr(*logical.left, ctx);
        match logical.type_ {
            LogicalType::And => self.compile_logical_jump(*logical.right, JumpType::IfFalse, ctx),
            LogicalType::Or  => self.compile_logical_jump(*logical.right, JumpType::IfTrue,  ctx),
        }
    }

    fn compile_logical_jump(&mut self, right: Expr, jump_type: JumpType, ctx: &mut Context) {
        let jump_op = self.emit_jump(jump_type, ctx);
        self.write_pop(ctx);

        self.compile_expr(right, ctx);

        self.patch_jump(jump_op, ctx);
    }

    fn compile_assign_expr(&mut self, assign: Assign, ctx: &mut Context) {

        self.compile_expr(*assign.value, ctx);

        let set_op = match self.resolve_local(&assign.target.name) {
            Some(index) => Op::SetLocal { index },
            None        => {
                let name = self.make_identifier_constant(assign.target.name, ctx);
                Op::SetGlobal { name, }
            }
        };

        self.write_op(set_op, ctx);
    }


    fn compile_binary_expr(&mut self, binary: BinaryOperator, ctx: &mut Context) {
        self.line = binary.operator.line;

        self.compile_expr(*binary.left,  ctx);
        self.compile_expr(*binary.right, ctx);

        type B = BinaryOpType;
        match binary.type_ {
            B::NotEqual     => self.write_ops(Op::Equal,   Op::Not, ctx),
            B::Equal        => self.write_op (Op::Equal,            ctx),
            B::Greater      => self.write_op (Op::Greater,          ctx),
            B::GreaterEqual => self.write_ops(Op::Less,    Op::Not, ctx),
            B::Less         => self.write_op (Op::Less,             ctx),
            B::LessEqual    => self.write_ops(Op::Greater, Op::Not, ctx),

            B::Add          => self.write_op (Op::Add,      ctx),
            B::Subtract     => self.write_op (Op::Subtract, ctx),
            B::Multiply     => self.write_op (Op::Multiply, ctx),
            B::Divide       => self.write_op (Op::Divide,   ctx),
        };
    }

    fn compile_call_expr(&mut self, _call: Call) {
        todo!()
    }

    fn compile_unary_expr(&mut self, unary: UnaryOperator, ctx: &mut Context) {
        self.line = unary.operator.line;

        self.compile_expr(*unary.right, ctx);

        type U = UnaryOpType;
        match unary.type_ {
            U::Negate     => self.write_op(Op::Negate, ctx),
            U::LogicalNot => self.write_op(Op::Not,    ctx),
        };
    }

    fn compile_var_expr(&mut self, var: Variable, ctx: &mut Context) {
        self.line = var.name.line;

        let local = self.resolve_local(&var.name);

        match local {
            Some(index) => self.write_op(Op::GetLocal { index, }, ctx),
            None        => {
                let name = self.make_identifier_constant(var.name, ctx);
                self.write_op(Op::GetGlobal { name }, ctx)
            }
        };

    }

    fn compile_get_expr(&mut self, get: Get, ctx: &mut Context) {
        self.line = get.name.line;

        let name = self.make_identifier_constant(get.name, ctx);
        self.write_op(Op::GetGlobal { name, }, ctx);
    }

    fn compile_set_expr(&mut self, set: Set, ctx: &mut Context) {
        self.line = set.name.line;

        let name = self.make_identifier_constant(set.name, ctx);
        self.compile_expr(*set.value, ctx);

        self.write_op(Op::SetGlobal { name, }, ctx);
    }

    fn compile_super_expr(&mut self, _super: Super) {
        todo!()
    }

    fn compile_this_expr(&mut self, _this: This) {
        todo!()
    }


    // Variables

    fn emit_constant(&mut self, value: Value, ctx: &mut Context) -> BytecodeIndex {
        let index = self.current_chunk_mut(ctx).add_constant(value);

        self.write_op(Op::Constant { index, }, ctx)
    }

    fn emit_jump(&mut self, jump: JumpType, ctx: &mut Context) -> BytecodeIndex {
        let max = Offset(usize::MAX);

        let op = match jump {
            JumpType::IfFalse => Op::JumpIfFalse { offset: max },
            JumpType::IfTrue  => Op::JumpIfTrue  { offset: max },
            JumpType::Always  => Op::Jump        { offset: max },
        };

        self.write_op(op, ctx)
    }

    fn patch_jump(&mut self, index: BytecodeIndex, ctx: &mut Context) {
        let index = index.0;

        let chunk = self.current_chunk_mut(ctx);

        let new_offset = chunk.code.len() - index -1;
        let new_offset = Offset(new_offset);

        let op = &mut chunk.code[index];

        match op {
            Op::JumpIfTrue  { offset } => *offset = new_offset,
            Op::JumpIfFalse { offset } => *offset = new_offset,
            Op::Jump        { offset } => *offset = new_offset,

            _ => panic!("The indexed op code is not a jump: index: {}, opcode: '{}'", index, op),
        };
    }

    fn emit_loop(&mut self, loop_start: BytecodeIndex, ctx: &mut Context) -> BytecodeIndex {
        let loop_start = loop_start.0;

        let offset = self.current_chunk(ctx).code.len() - loop_start +1;
        let offset = Offset(offset);

        self.write_op(Op::Loop { offset, }, ctx)
    }


    fn make_identifier_constant(&mut self, name: Token, ctx: &mut Context) -> ConstIndex {
        let val = str_to_val(name.lexeme, ctx);

        let index = self.current_chunk_mut(ctx).add_constant(val);

        index
    }

    fn declare_local(&mut self, name: &Token) {
        // TODO: allow locals to shadow each other?
        for local in self.current_func().locals.iter().rev() {
            if local.initialized && local.depth < self.scope_depth {
                break;
            }

            if local.name.lexeme == name.lexeme {
                panic!("todo, make this a compiler error")
            }
        }

        self.add_local(name.clone());
    }

    fn define_global(&mut self, index: ConstIndex, ctx: &mut Context) {
        self.write_op(Op::DefGlobal { name: index, }, ctx);
    }

    fn add_local(&mut self, name: Token) {
        let depth = self.scope_depth;

        self.current_func_mut().locals.push(Local {
            name,
            depth,
            initialized: false,
        });
    }

    fn resolve_local(&self, name: &Token) -> Option<StackIndex> {
        for (i, local) in self.current_func().locals.iter().enumerate().rev() {

            if local.name.lexeme == name.lexeme {

                if !local.initialized {
                    panic!("Can't read local variable in its own initializer")
                }

                return Some(StackIndex(i));
            }
        }

        None
    }

    fn mark_initialized(&mut self) {
        if self.scope_depth == 0 {
            return;
        }

        let local = self.current_func_mut().locals.last_mut().expect("No Local to mark initialized");

        local.initialized = true;
    }


    // utils

    fn current_chunk<'a>(&self, ctx: &'a Context) -> &'a Chunk {
        let func_id = self.current_func().func_obj;

        let func = ctx.get(func_id);

        let func: &ObjFunction = func.into();

        &func.chunk
    }

    fn current_chunk_mut<'b>(&mut self, ctx: &'b mut Context) -> &'b mut Chunk {
        let func_id = self.current_func().func_obj;

        let func = ctx.get_mut(func_id);

        let func: &'b mut ObjFunction = func.into();

        &mut func.chunk
    }

    fn current_func(&self) -> &Func {
        self.functions.last().expect("Function stack must not be empty")
    }

    fn current_func_mut(&mut self) -> &mut Func {
        self.functions.last_mut().expect("Function stack must not be empty")
    }

    fn push_func(&mut self, func_type: FuncType, func_id: ObjectId, first_slot: Local) {
        self.functions.push(Func::new(func_type, func_id, first_slot));
    }

    fn pop_func(&mut self) -> Func {
        self.functions.pop().expect("Function stack must not be empty")
    }

    fn write_op(&mut self, op: OpCode, ctx: &mut Context) -> BytecodeIndex {
        let line = self.line;
        self.current_chunk_mut(ctx).write_op(op, line)
    }
    fn write_ops(&mut self, op1: OpCode, op2: OpCode, ctx: &mut Context) -> BytecodeIndex {
        let line = self.line;
        let chunk = self.current_chunk_mut(ctx);
        chunk.write_op(op1, line);
        chunk.write_op(op2, line)
    }

    fn write_pop(&mut self, ctx: &mut Context) -> BytecodeIndex {
        self.write_op(Op::Pop, ctx)
    }

    fn begin_scope(&mut self) {
        self.scope_depth += 1;
    }

    fn end_scope(&mut self, ctx: &mut Context) {
        self.scope_depth -= 1;

        let depth  = self.scope_depth;
        let locals = &mut self.current_func_mut().locals;

        let pop_count = locals.iter().filter(|l| l.depth > depth).count();

        for _ in 0..pop_count {
            locals.pop();
        }

        for _ in 0..pop_count {
            self.write_pop(ctx);
        }
    }

}


fn to_number(lexeme: &str) -> f64 {
    lexeme.parse().expect("Unable lexeme to convert to f64")
}

fn str_to_val(string: String, ctx: &mut Context) -> Value {
    let obj = ctx.add_string(&string);

    Value::Obj(obj)
}
