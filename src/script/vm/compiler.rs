
use std::{cell::{Ref, RefMut}, usize};

use gc_arena::{Gc, Mutation, lock::{GcRefLock}};

use crate::script::{
    ast::*,
    tokens::{Token, TokenType},
    vm::{
        Root, chunk::*, object::{ObjPtr, ObjFunction}
    }
};

use super::{chunk::{Chunk, OpCode}, value::Value};

type Op<'gc> = OpCode<'gc>;

// type Func = (FuncType, ObjectId);

pub fn compile<'gc>(ast: Ast, root: &'gc mut Root<'gc>, ctx: &'gc Mutation<'gc>) ->
    CompilerResult<Gc<'gc, ObjFunction<'gc>>>
{

    let mut compiler = Compiler::new(root, ctx);

    for stmt in ast.stmts {
        compiler.compile_stmt(stmt)?;
    }

    compiler.write_op(Op::Return);

    let len = compiler.function_stack.len();
    assert_eq!(len, 1, "expect function stack to only contain top level script object: {} elements found", len);

    let script_func = compiler.function_stack
        .pop()
        .unwrap()
        .func_obj
    ;

    let script_func = Gc::new(ctx, script_func);

    compiler.root.functions.push(script_func);

    Ok(script_func)
}



struct Compiler<'gc> {
    root:           &'gc mut Root<'gc>,
    ctx:            &'gc Mutation<'gc>,
    line:           usize,
    scope_depth:    usize,
    function_stack: Vec<Func<'gc>>,

    upvalues:       Vec<Vec<ObjPtr<'gc>>>,

    constants:      Vec<Value<'gc>>,
}

#[derive(Debug)]
struct Local {
    name:        Token,
    depth:       usize,
    initialized: bool,
}

#[derive(Debug)]
struct Upvalue {
    index:       StackIndex,
    is_local:    bool,
}

enum VariableType {
    Global,
    Local,
}

enum FuncType {
    Function,
    Script,
}

struct Func<'gc> {
    pub type_:    FuncType,
    pub upvalues: Vec<Upvalue>,
    pub chunk:    GcRefLock<'gc, Chunk<'gc>>,
    pub func_obj: ObjFunction<'gc>,
}



#[derive(Debug)]
pub struct CompileError {
    pub msg: String
}

pub type CompilerResult<T> = Result<T, CompileError>;

#[derive(Debug)]
enum JumpType {
    IfFalse,
    IfTrue,
    Always,
}

impl<'gc> Func<'gc> {
    pub fn new(type_: FuncType, func_obj: ObjFunction<'gc>, ctx: &Mutation<'gc>) -> Self {
        Self {
            type_,
            func_obj,
            chunk:    Chunk::new(ctx),
            upvalues: Vec  ::new(),
        }
    }
}

impl<'gc> Compiler<'gc> {

    fn new(root: &'gc mut Root<'gc>, ctx: &'gc Mutation<'gc>) -> Self {

        let chunk = Chunk::new(ctx);
        let func  = ObjFunction::new("script".to_owned(), 0, chunk);

        Self {
            root,
            ctx,

            line:           0,
            scope_depth:    0,
            function_stack: vec![Func::new(FuncType::Script, func, ctx)],

            constants:      vec![],
            upvalues:       vec![vec![]],
        }
    }

    // Statements

    fn compile_stmt(&mut self, stmt: Stmt) -> CompilerResult<()> {
        match stmt {
            Stmt::Block      (stmt) => self.compile_block_stmt (stmt)?,
            Stmt::Class      (stmt) => self.compile_class_decl (stmt),
            Stmt::Expression (stmt) => self.compile_expr_stmt  (stmt),
            Stmt::Function   (stmt) => self.compile_func_decl  (stmt)?,
            Stmt::If         (stmt) => self.compile_if_stmt    (stmt)?,
            Stmt::Print      (stmt) => self.compile_print_stmt (stmt.expr),
            Stmt::Return     (stmt) => self.compile_return_stmt(stmt),
            Stmt::Var        (stmt) => self.compile_var_decl   (stmt)?,
            Stmt::While      (stmt) => self.compile_while_stmt (stmt)?,
        };

        Ok(())
    }

    // statments must not leave "temporaries" on the stack (which are generated by expressions)

    fn compile_block_stmt(&mut self, block: Block) -> CompilerResult<()> {
        self.begin_scope();

        for stmt in *block.stmts {
            self.compile_stmt(stmt)?;
        }

        self.end_scope(block.locals);
        Ok(())
    }

    fn compile_class_decl(&mut self, class: Class) {

        let is_global = self.declare_variable(&class.name);

        // declare variable doesn't create a name constant, if the variable is a local
        let name_idx  = is_global.unwrap_or_else(|| self.make_identifier_constant(class.name));

        self.write_op(Op::Class { name_idx });

        if is_global.is_some() {
            self.define_global(name_idx);
        }

        self.write_op(Op::Pop);

    }

    fn compile_expr_stmt(&mut self, expr_stmt: ExpressionStmt) {
        self.compile_expr(expr_stmt.expr);
        self.write_pop();
    }

    fn compile_func_decl(&mut self, func: FunctionStmt) -> CompilerResult<()> {

        let global_idx = self.declare_variable(&func.name);

        let obj = self.make_function(func, FuncType::Function)?;



        self.write_op(Op::Closure { func: obj });

        if let Some(name_idx) = global_idx {
            self.define_global(name_idx);
        }


        Ok(())
    }

    fn make_function(&mut self,
        stmt:      FunctionStmt,
        func_type: FuncType,
    )
        -> CompilerResult<Gc<'gc, ObjFunction<'gc>>>
    {

        let chunk = Chunk::new(self.ctx);
        let func  = ObjFunction::new(stmt.name.lexeme, stmt.params.len(), chunk);
        let func  = Func::new(func_type, func, self.ctx);

        self.function_stack.push(func);

        self.begin_scope();

        for (i, _) in stmt.params.iter().enumerate().filter(|a| a.1.var_type == VarDeclType::Upvalue) {
            self.write_op(Op::PushUpvalue { index: StackOffset(i) });
        }

        for stmt in stmt.body.into_iter() {
            self.compile_stmt(stmt)?;
        }

        let implicit_return = ReturnStmt::new(
            Token::new(
                TokenType::Return, "return", 0, 0),
            None,
        );
        self.compile_stmt(implicit_return)?;

        let func = self.pop_func();
        self.end_scope(0);           // return is responsible for popping func locals off the stack

        let (mut func, chunk) = (func.func_obj, func.chunk);

        func.chunk = chunk;
        let func   = Gc::new(self.ctx, func);

        Ok(func)

    }

    fn compile_if_stmt(&mut self, if_stmt: IfStmt) -> CompilerResult<()> {

        self.compile_expr(if_stmt.condition);

        let jump_then_op = self.emit_jump(JumpType::IfFalse); // goto: Else

        // Pop the condition temporary if no jump
        self.write_pop();
        self.compile_stmt(*if_stmt.then_branch)?;
        let jump_else_op = self.emit_jump(JumpType::Always);  // goto: End


        // Else:
        self.patch_jump(jump_then_op);

        // Pop the condition temporary if jump
        self.write_pop();
        if let Some(stmt) = if_stmt.else_branch {
            self.compile_stmt(*stmt)?;
        }


        // End:
        self.patch_jump(jump_else_op);

        Ok(())
    }


    fn compile_print_stmt(&mut self, expr: Expr) {
        self.compile_expr(expr);
        self.write_op(Op::Print);
    }

    fn compile_return_stmt(&mut self, return_: ReturnStmt) {
        match return_.value {
            Some(val) => { self.compile_expr(val); },
            None      => { self.write_op(Op::Nil); },
        }

        self.write_op(Op::Return);
    }

    fn compile_var_decl(&mut self, stmt: VarStmt) -> CompilerResult<()> {
        let global = self.declare_variable(&stmt.name);

        match stmt.initializer {
            Some(expr) =>   self.compile_expr(expr),
            None       => { self.write_op(Op::Nil); }
        }

        if let Some(index) = global{
            self.define_global(index);
        }

        if stmt.var_type == VarDeclType::Upvalue {
            self.write_op(OpCode::PushUpvalue { index: StackOffset(0) });
        }

        Ok(())
    }

    fn declare_variable(&mut self, name: &Token) -> Option<ConstIndex> {
        self.line = name.line;

        (self.scope_depth == 0).then(||
            self.make_identifier_constant(name.clone())
        )

    }

    fn compile_while_stmt(&mut self, while_: WhileStmt) -> CompilerResult<()> {
        let loop_start = self.current_bytecode_index();

        self.compile_expr(while_.condition);

        let exit_jump_op = self.emit_jump(JumpType::IfFalse);
        self.write_pop();

        self.compile_stmt(*while_.body)?;
        self.emit_loop(loop_start);

        self.patch_jump(exit_jump_op);
        self.write_pop();

        Ok(())
    }


    // Expressions

    fn compile_expr(&mut self, expr: Expr) {
        match expr {
            Expr::Assign   (expr) => self.compile_assign_expr (expr),
            Expr::Binary   (expr) => self.compile_binary_expr (expr),
            Expr::Call     (expr) => self.compile_call_expr   (expr),
            Expr::Get      (expr) => self.compile_get_expr    (expr),
            Expr::Grouping (expr) => self.compile_expr        (*expr.expr),
            Expr::Literal  (expr) => self.compile_literal_expr(expr),
            Expr::Logical  (expr) => self.compile_logical_expr(expr),
            Expr::Set      (expr) => self.compile_set_expr    (expr),
            Expr::Super    (expr) => self.compile_super_expr  (expr),
            Expr::This     (expr) => self.compile_this_expr   (expr),
            Expr::Unary    (expr) => self.compile_unary_expr  (expr),
            Expr::Variable (expr) => self.compile_var_expr    (expr),
        };

        // sdlfkjsdflkjsdf
    }

    fn compile_literal_expr(&mut self, literal: Literal) {
        let value = literal.value;
        self.line = value.line;

        match literal.type_ {
            LiteralType::Number => {
                let value = Value::Number(to_number(&value.lexeme));
                self.emit_constant(value);
            },
            LiteralType::String => {
                let value = self.new_str_val(value.lexeme.to_owned());
                self.emit_constant(value);
            },
            LiteralType::True   => { self.write_op(Op::True);  },
            LiteralType::False  => { self.write_op(Op::False); },
            LiteralType::Nil    => { self.write_op(Op::Nil);   },
        };
    }

    fn compile_logical_expr(&mut self, logical: Logical) {
        self.compile_expr(*logical.left);
        match logical.type_ {
            LogicalType::And => self.compile_logical_jump(*logical.right, JumpType::IfFalse),
            LogicalType::Or  => self.compile_logical_jump(*logical.right, JumpType::IfTrue),
        }
    }

    fn compile_logical_jump(&mut self, right: Expr, jump_type: JumpType) {
        let jump_op = self.emit_jump(jump_type);
        self.write_pop();

        self.compile_expr(right);

        self.patch_jump(jump_op);
    }

    fn compile_assign_expr(&mut self, assign: Assign) {

        self.compile_expr(*assign.value);

        let set_op = match assign.target.var_type {
            VarType::Local  (offset) => Op::SetLocal   { offset },
            VarType::Upvalue(index)  => Op::SetUpvalue { index },
            VarType::Global          => {
                let name_idx = self.make_identifier_constant(assign.target.name);
                Op::SetGlobal { name_idx }
            }
        };

        self.write_op(set_op);
    }


    fn compile_binary_expr(&mut self, binary: BinaryOperator) {
        self.line = binary.operator.line;

        self.compile_expr(*binary.left);
        self.compile_expr(*binary.right);

        type B = BinaryOpType;
        match binary.type_ {
            B::NotEqual     => self.write_ops(Op::Equal,   Op::Not),
            B::Equal        => self.write_op (Op::Equal           ),
            B::Greater      => self.write_op (Op::Greater         ),
            B::GreaterEqual => self.write_ops(Op::Less,    Op::Not),
            B::Less         => self.write_op (Op::Less            ),
            B::LessEqual    => self.write_ops(Op::Greater, Op::Not),

            B::Add          => self.write_op (Op::Add),
            B::Subtract     => self.write_op (Op::Subtract),
            B::Multiply     => self.write_op (Op::Multiply),
            B::Divide       => self.write_op (Op::Divide),
        };
    }

    fn compile_call_expr(&mut self, call: Call) {

        let arity = call.args.len();

        self.compile_expr(*call.callee);
        for arg in call.args.into_iter() {
            self.compile_expr(arg);
        }

        self.write_op(Op::Call { arg_count: arity });

    }

    fn compile_unary_expr(&mut self, unary: UnaryOperator) {
        self.line = unary.operator.line;

        self.compile_expr(*unary.right);

        type U = UnaryOpType;
        match unary.type_ {
            U::Negate     => self.write_op(Op::Negate),
            U::LogicalNot => self.write_op(Op::Not),
        };
    }

    fn compile_var_expr(&mut self, var: Variable) {
        self.line = var.name.line;

        let get_op = match var.var_type {
            VarType::Local  (offset) => Op::GetLocal   { offset },
            VarType::Upvalue(index)  => Op::GetUpvalue { index },
            VarType::Global         => {
                let name_idx = self.make_identifier_constant(var.name);
                Op::GetGlobal  { name_idx }
            }
        };

        self.write_op(get_op);

    }

    fn compile_get_expr(&mut self, get: Get) {
        self.line = get.name.line;

        let name_idx = self.make_identifier_constant(get.name);

        self.write_op(Op::GetProperty { name_idx, });
    }

    fn compile_set_expr(&mut self, set: Set) {
        self.line = set.name.line;

        let name_idx = self.make_identifier_constant(set.name);
        self.compile_expr(*set.value);

        self.write_op(Op::SetProperty { name_idx, });
    }

    fn compile_super_expr(&mut self, _super: Super) {
        todo!()
    }

    fn compile_this_expr(&mut self, _this: This) {
        todo!()
    }


    // Variables

    fn emit_constant(&mut self, value: Value<'gc>) -> BytecodeIndex {
        let index = self.add_constant(value);

        self.write_op(Op::GetConstant { index, } )
    }

    fn emit_jump(&mut self, jump: JumpType) -> BytecodeIndex {
        let max = Offset(usize::MAX);

        let op = match jump {
            JumpType::IfFalse => Op::JumpIfFalse { offset: max },
            JumpType::IfTrue  => Op::JumpIfTrue  { offset: max },
            JumpType::Always  => Op::Jump        { offset: max },
        };

        self.write_op(op)
    }

    fn patch_jump(&mut self, index: BytecodeIndex) {
        let index = index.0;

        let mut chunk = self.current_chunk_mut();

        let new_offset = chunk.code.len() - index -1;
        let new_offset = Offset(new_offset);

        let op = &mut chunk.code[index];

        match op {
            Op::JumpIfTrue  { offset } => *offset = new_offset,
            Op::JumpIfFalse { offset } => *offset = new_offset,
            Op::Jump        { offset } => *offset = new_offset,

            _ => panic!("The indexed op code is not a jump: index: {}, opcode: '{}'", index, op),
        };
    }

    fn emit_loop(&mut self, loop_start: BytecodeIndex) -> BytecodeIndex {
        let loop_start = loop_start.0;

        let offset = self.current_chunk().code.len() - loop_start +1;
        let offset = Offset(offset);

        self.write_op(Op::Loop { offset, })
    }


    fn make_identifier_constant(&mut self, name: Token) -> ConstIndex {
        let val   = self.new_str_val(name.lexeme);
        let index = self.add_constant(val);

        index
    }

    fn define_global(&mut self, name_idx: ConstIndex) {
        self.write_op(
            Op::DefGlobal { name_idx, },
        );
    }


    // utils

    pub fn add_constant(&mut self, value: Value<'gc>) -> ConstIndex {
        let index = self.constants.len();

        self.root.constants.push(value);

        ConstIndex(index)
    }

    fn current_chunk(&self) -> Ref<'gc, Chunk<'gc>> {
        self.current_func().chunk.borrow()

    }

    fn current_chunk_mut(&self) -> RefMut<'gc, Chunk<'gc>> {
        self.current_func().chunk.borrow_mut(self.ctx)

    }

    fn current_func(&self) -> &Func<'gc> {
        self.function_stack.last().expect("Function stack must not be empty")
    }

    fn current_func_mut(&mut self) -> &mut Func<'gc> {
        self.function_stack.last_mut().expect("Function stack must not be empty")
    }

    fn current_bytecode_index(&self) -> BytecodeIndex {
        BytecodeIndex(self.current_chunk().code.len())
    }

    fn pop_func(&mut self) -> Func<'gc> {
        self.function_stack.pop().expect("Function stack must not be empty")
    }

    fn write_op(&mut self, op: OpCode<'gc>) -> BytecodeIndex {
        let line = self.line;
        self.current_chunk_mut().write_op(op, line)
    }
    fn write_ops(&mut self, op1: OpCode<'gc>, op2: OpCode<'gc>) -> BytecodeIndex {
        let line = self.line;
        let mut chunk = self.current_chunk_mut();
        chunk.write_op(op1, line);
        chunk.write_op(op2, line)
    }

    fn write_pop(&mut self) -> BytecodeIndex {

        self.write_op(Op::Pop)
    }

    fn begin_scope(&mut self) {
        self.scope_depth += 1;
    }

    fn end_scope(&mut self, pop_count: usize) {
        self.scope_depth -= 1;

        for _ in 0..pop_count {
            self.write_pop();
        }
    }

    // TODO: string interning
    fn new_str_obj(&self, s: String) -> ObjPtr<'gc> {
        ObjPtr::new_string(s, self.ctx)
    }

    // TODO: string interning
    fn new_str_val(&mut self, s: String) -> Value<'gc> {
        Value::Obj(self.new_str_obj(s))
    }
}


fn to_number(lexeme: &str) -> f64 {
    lexeme.parse().expect("Unable lexeme to convert to f64")
}
